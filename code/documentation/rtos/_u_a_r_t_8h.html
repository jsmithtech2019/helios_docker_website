<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios RTOS: Drivers/UART/UART.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios RTOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_u_a_r_t_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>UART driver interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="_u_a_r_t_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Parameters.  <a href="struct_u_a_r_t___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___fxn_table.html">UART_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation.  <a href="struct_u_a_r_t___fxn_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___config.html">UART_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="struct_u_a_r_t___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0f5a809e0884da33fef102236eb51644"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga0f5a809e0884da33fef102236eb51644">UART_CMD_RESERVED</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ga0f5a809e0884da33fef102236eb51644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f35027907fbab6a9ee302d2ee52a879"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_o_n_t_r_o_l.html#ga8f35027907fbab6a9ee302d2ee52a879">UART_STATUS_RESERVED</a>&#160;&#160;&#160;-32</td></tr>
<tr class="separator:ga8f35027907fbab6a9ee302d2ee52a879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga101b7761f89b3ec49f0c6726669acfed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed">UART_STATUS_SUCCESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga101b7761f89b3ec49f0c6726669acfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a>.  <a href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed">More...</a><br /></td></tr>
<tr class="separator:ga101b7761f89b3ec49f0c6726669acfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae076f4aae13ca8e2aea674207df0ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">UART_STATUS_ERROR</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:ga2ae076f4aae13ca8e2aea674207df0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a>.  <a href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">More...</a><br /></td></tr>
<tr class="separator:ga2ae076f4aae13ca8e2aea674207df0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61125a2eb8059fd8b96ad95edc68ac2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga61125a2eb8059fd8b96ad95edc68ac2b">UART_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:ga61125a2eb8059fd8b96ad95edc68ac2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a> for undefined command codes.  <a href="group___u_a_r_t___s_t_a_t_u_s.html#ga61125a2eb8059fd8b96ad95edc68ac2b">More...</a><br /></td></tr>
<tr class="separator:ga61125a2eb8059fd8b96ad95edc68ac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942596a37cb2109ae021f88f3d907bdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga942596a37cb2109ae021f88f3d907bdc">UART_CMD_PEEK</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga942596a37cb2109ae021f88f3d907bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a> to read the next unsigned char.  <a href="group___u_a_r_t___c_m_d.html#ga942596a37cb2109ae021f88f3d907bdc">More...</a><br /></td></tr>
<tr class="separator:ga942596a37cb2109ae021f88f3d907bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5be6db621c5b048637dc93b26797693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gaf5be6db621c5b048637dc93b26797693">UART_CMD_ISAVAILABLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf5be6db621c5b048637dc93b26797693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a> to determine if the read buffer is empty.  <a href="group___u_a_r_t___c_m_d.html#gaf5be6db621c5b048637dc93b26797693">More...</a><br /></td></tr>
<tr class="separator:gaf5be6db621c5b048637dc93b26797693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470321cbd9eccf137ffbe6553ae7f35f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga470321cbd9eccf137ffbe6553ae7f35f">UART_CMD_GETRXCOUNT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga470321cbd9eccf137ffbe6553ae7f35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a> to determine how many unsigned chars are in the read buffer.  <a href="group___u_a_r_t___c_m_d.html#ga470321cbd9eccf137ffbe6553ae7f35f">More...</a><br /></td></tr>
<tr class="separator:ga470321cbd9eccf137ffbe6553ae7f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67d01fa376f25bb28141d819647e8d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gad67d01fa376f25bb28141d819647e8d3">UART_CMD_RXENABLE</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gad67d01fa376f25bb28141d819647e8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a> to enable data receive by the UART.  <a href="group___u_a_r_t___c_m_d.html#gad67d01fa376f25bb28141d819647e8d3">More...</a><br /></td></tr>
<tr class="separator:gad67d01fa376f25bb28141d819647e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b19ce2fa9f43d3fe255bcdbd3cda7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#gac0b19ce2fa9f43d3fe255bcdbd3cda7b">UART_CMD_RXDISABLE</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gac0b19ce2fa9f43d3fe255bcdbd3cda7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d" title="Function performs implementation specific features on a given UART_Handle.">UART_control()</a> to disable data received by the UART.  <a href="group___u_a_r_t___c_m_d.html#gac0b19ce2fa9f43d3fe255bcdbd3cda7b">More...</a><br /></td></tr>
<tr class="separator:gac0b19ce2fa9f43d3fe255bcdbd3cda7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3562e7931cf51b41a32d8109072251"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a7e3562e7931cf51b41a32d8109072251">UART_ERROR</a>&#160;&#160;&#160;<a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">UART_STATUS_ERROR</a></td></tr>
<tr class="separator:a7e3562e7931cf51b41a32d8109072251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada620b673241eb6335a71e75da291716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ada620b673241eb6335a71e75da291716">UART_WAIT_FOREVER</a>&#160;&#160;&#160;(~0)</td></tr>
<tr class="memdesc:ada620b673241eb6335a71e75da291716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define.  <a href="_u_a_r_t_8h.html#ada620b673241eb6335a71e75da291716">More...</a><br /></td></tr>
<tr class="separator:ada620b673241eb6335a71e75da291716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a13cc669fae768d8212e6491ce71b28af"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___config.html">UART_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a></td></tr>
<tr class="memdesc:a13cc669fae768d8212e6491ce71b28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> call.  <a href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">More...</a><br /></td></tr>
<tr class="separator:a13cc669fae768d8212e6491ce71b28af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44620a9d91e0357ebc6f0a79984d9e1e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a44620a9d91e0357ebc6f0a79984d9e1e">UART_Callback</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>, void *buf, size_t count)</td></tr>
<tr class="memdesc:a44620a9d91e0357ebc6f0a79984d9e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART driver when used in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> The callback can occur in task or HWI context.  <a href="_u_a_r_t_8h.html#a44620a9d91e0357ebc6f0a79984d9e1e">More...</a><br /></td></tr>
<tr class="separator:a44620a9d91e0357ebc6f0a79984d9e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821a1d8d175e0b1f656a00dc623d4860"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a821a1d8d175e0b1f656a00dc623d4860">UART_Mode</a></td></tr>
<tr class="memdesc:a821a1d8d175e0b1f656a00dc623d4860"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="_u_a_r_t_8h.html#a821a1d8d175e0b1f656a00dc623d4860">More...</a><br /></td></tr>
<tr class="separator:a821a1d8d175e0b1f656a00dc623d4860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97d52284ddcb61165e13cfb46425fd9"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac97d52284ddcb61165e13cfb46425fd9">UART_ReturnMode</a></td></tr>
<tr class="memdesc:ac97d52284ddcb61165e13cfb46425fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="_u_a_r_t_8h.html#ac97d52284ddcb61165e13cfb46425fd9">More...</a><br /></td></tr>
<tr class="separator:ac97d52284ddcb61165e13cfb46425fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcc0767be6a635e2622cdd2cbf8f4fa"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#addcc0767be6a635e2622cdd2cbf8f4fa">UART_DataMode</a></td></tr>
<tr class="memdesc:addcc0767be6a635e2622cdd2cbf8f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="_u_a_r_t_8h.html#addcc0767be6a635e2622cdd2cbf8f4fa">More...</a><br /></td></tr>
<tr class="separator:addcc0767be6a635e2622cdd2cbf8f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2458fc15500d4596b67e695a62eef8f9"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a2458fc15500d4596b67e695a62eef8f9">UART_Echo</a></td></tr>
<tr class="memdesc:a2458fc15500d4596b67e695a62eef8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="_u_a_r_t_8h.html#a2458fc15500d4596b67e695a62eef8f9">More...</a><br /></td></tr>
<tr class="separator:a2458fc15500d4596b67e695a62eef8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbb2d50547dee530b8c2666985efcd3"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aacbb2d50547dee530b8c2666985efcd3">UART_LEN</a></td></tr>
<tr class="memdesc:aacbb2d50547dee530b8c2666985efcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="_u_a_r_t_8h.html#aacbb2d50547dee530b8c2666985efcd3">More...</a><br /></td></tr>
<tr class="separator:aacbb2d50547dee530b8c2666985efcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63afe876d1474c7497d90e1052049ed6"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a63afe876d1474c7497d90e1052049ed6">UART_STOP</a></td></tr>
<tr class="memdesc:a63afe876d1474c7497d90e1052049ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="_u_a_r_t_8h.html#a63afe876d1474c7497d90e1052049ed6">More...</a><br /></td></tr>
<tr class="separator:a63afe876d1474c7497d90e1052049ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4fac552566aa6fce6ddda0ce1bc7b8"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a5e4fac552566aa6fce6ddda0ce1bc7b8">UART_PAR</a></td></tr>
<tr class="memdesc:a5e4fac552566aa6fce6ddda0ce1bc7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="_u_a_r_t_8h.html#a5e4fac552566aa6fce6ddda0ce1bc7b8">More...</a><br /></td></tr>
<tr class="separator:a5e4fac552566aa6fce6ddda0ce1bc7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbbaa6af11fae4b97cc55d1a309e063"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#acdbbaa6af11fae4b97cc55d1a309e063">UART_Params</a></td></tr>
<tr class="memdesc:acdbbaa6af11fae4b97cc55d1a309e063"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Parameters.  <a href="_u_a_r_t_8h.html#acdbbaa6af11fae4b97cc55d1a309e063">More...</a><br /></td></tr>
<tr class="separator:acdbbaa6af11fae4b97cc55d1a309e063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6">UART_CloseFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn().">UART_CloseFxn()</a>.  <a href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6">More...</a><br /></td></tr>
<tr class="separator:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc98447e6dd805e2d072917e8e6da3b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a4fc98447e6dd805e2d072917e8e6da3b">UART_ControlFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, unsigned int cmd, void *arg)</td></tr>
<tr class="memdesc:a4fc98447e6dd805e2d072917e8e6da3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a4fc98447e6dd805e2d072917e8e6da3b" title="A function pointer to a driver specific implementation of UART_ControlFxn().">UART_ControlFxn()</a>.  <a href="_u_a_r_t_8h.html#a4fc98447e6dd805e2d072917e8e6da3b">More...</a><br /></td></tr>
<tr class="separator:a4fc98447e6dd805e2d072917e8e6da3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e89df3065fffb47e7354067c14d1b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b">UART_InitFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a2b3e89df3065fffb47e7354067c14d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn().">UART_InitFxn()</a>.  <a href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b">More...</a><br /></td></tr>
<tr class="separator:a2b3e89df3065fffb47e7354067c14d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e21ac60f24eb9ce32286e21de713d1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1">UART_OpenFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:a39e21ac60f24eb9ce32286e21de713d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1" title="A function pointer to a driver specific implementation of UART_OpenFxn().">UART_OpenFxn()</a>.  <a href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1">More...</a><br /></td></tr>
<tr class="separator:a39e21ac60f24eb9ce32286e21de713d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d855b637a26d787afec822d4cd2978e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a4d855b637a26d787afec822d4cd2978e">UART_ReadFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a4d855b637a26d787afec822d4cd2978e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a4d855b637a26d787afec822d4cd2978e" title="A function pointer to a driver specific implementation of UART_ReadFxn().">UART_ReadFxn()</a>.  <a href="_u_a_r_t_8h.html#a4d855b637a26d787afec822d4cd2978e">More...</a><br /></td></tr>
<tr class="separator:a4d855b637a26d787afec822d4cd2978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b57fb6a7c48272141a727c7de7290e4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a6b57fb6a7c48272141a727c7de7290e4">UART_ReadPollingFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a6b57fb6a7c48272141a727c7de7290e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a6b57fb6a7c48272141a727c7de7290e4" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn().">UART_ReadPollingFxn()</a>.  <a href="_u_a_r_t_8h.html#a6b57fb6a7c48272141a727c7de7290e4">More...</a><br /></td></tr>
<tr class="separator:a6b57fb6a7c48272141a727c7de7290e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46296acc2c197a775d44458e1eca197"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197">UART_ReadCancelFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:aa46296acc2c197a775d44458e1eca197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn().">UART_ReadCancelFxn()</a>.  <a href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197">More...</a><br /></td></tr>
<tr class="separator:aa46296acc2c197a775d44458e1eca197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ee32e202ad90d912b27693fe33672"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#abe7ee32e202ad90d912b27693fe33672">UART_WriteFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:abe7ee32e202ad90d912b27693fe33672"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#abe7ee32e202ad90d912b27693fe33672" title="A function pointer to a driver specific implementation of UART_WriteFxn().">UART_WriteFxn()</a>.  <a href="_u_a_r_t_8h.html#abe7ee32e202ad90d912b27693fe33672">More...</a><br /></td></tr>
<tr class="separator:abe7ee32e202ad90d912b27693fe33672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0b77abdb9da6a868edc6529ae70ff"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a68d0b77abdb9da6a868edc6529ae70ff">UART_WritePollingFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:a68d0b77abdb9da6a868edc6529ae70ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a68d0b77abdb9da6a868edc6529ae70ff" title="A function pointer to a driver specific implementation of UART_WritePollingFxn().">UART_WritePollingFxn()</a>.  <a href="_u_a_r_t_8h.html#a68d0b77abdb9da6a868edc6529ae70ff">More...</a><br /></td></tr>
<tr class="separator:a68d0b77abdb9da6a868edc6529ae70ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3d974279a2d161746dfbc8ca91774"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774">UART_WriteCancelFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ac5a3d974279a2d161746dfbc8ca91774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn().">UART_WriteCancelFxn()</a>.  <a href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774">More...</a><br /></td></tr>
<tr class="separator:ac5a3d974279a2d161746dfbc8ca91774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53155d6826ff6005b2a429d9ae20626"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___fxn_table.html">UART_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ad53155d6826ff6005b2a429d9ae20626">UART_FxnTable</a></td></tr>
<tr class="memdesc:ad53155d6826ff6005b2a429d9ae20626"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation.  <a href="_u_a_r_t_8h.html#ad53155d6826ff6005b2a429d9ae20626">More...</a><br /></td></tr>
<tr class="separator:ad53155d6826ff6005b2a429d9ae20626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c7a79c58daec6f156815ebd9739c69"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___config.html">UART_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ae8c7a79c58daec6f156815ebd9739c69">UART_Config</a></td></tr>
<tr class="memdesc:ae8c7a79c58daec6f156815ebd9739c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="_u_a_r_t_8h.html#ae8c7a79c58daec6f156815ebd9739c69">More...</a><br /></td></tr>
<tr class="separator:ae8c7a79c58daec6f156815ebd9739c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2507a620dba95cd20885c52494d19e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a> { <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, 
<a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>
 }</td></tr>
<tr class="memdesc:a2507a620dba95cd20885c52494d19e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">More...</a><br /></td></tr>
<tr class="separator:a2507a620dba95cd20885c52494d19e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5a82843435a1b5d51b6c27028d914f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a> { <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>, 
<a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a>
 }</td></tr>
<tr class="memdesc:acb5a82843435a1b5d51b6c27028d914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">More...</a><br /></td></tr>
<tr class="separator:acb5a82843435a1b5d51b6c27028d914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694090fdb166f94ac30b809f9cba87b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a> { <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a> = 1
 }</td></tr>
<tr class="memdesc:a694090fdb166f94ac30b809f9cba87b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">More...</a><br /></td></tr>
<tr class="separator:a694090fdb166f94ac30b809f9cba87b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a> { <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306">UART_ECHO_ON</a> = 1
 }</td></tr>
<tr class="memdesc:aac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">More...</a><br /></td></tr>
<tr class="separator:aac6a03c2e1d76f53e1d9d923dcdc24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf245d5f10db0abcbd8ad62a0d80c694"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a> { <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a27d04dd1fa818f764eb9b8e849feb7ff">UART_LEN_5</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a5bfd5507335d394d826e560930ce2a12">UART_LEN_6</a> = 1, 
<a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a2ac8467047f55cc1954388bf94c72e35">UART_LEN_7</a> = 2, 
<a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694a31abbaaeaa38a5c66fbe13bfc8ece221">UART_LEN_8</a> = 3
 }</td></tr>
<tr class="memdesc:adf245d5f10db0abcbd8ad62a0d80c694"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">More...</a><br /></td></tr>
<tr class="separator:adf245d5f10db0abcbd8ad62a0d80c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176b71ca19bc13d7534fa30fc18c2243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a> { <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243a9bfa599e95c5da9cfe5f964dab8a9c6c">UART_STOP_ONE</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243a3f41137f3775e7d33fdb250471c0248e">UART_STOP_TWO</a> = 1
 }</td></tr>
<tr class="memdesc:a176b71ca19bc13d7534fa30fc18c2243"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">More...</a><br /></td></tr>
<tr class="separator:a176b71ca19bc13d7534fa30fc18c2243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70b5aa75500b8c45a51ec560deccfc4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a> { <br />
&#160;&#160;<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a469955a283c95f261990ad07043d5d2d">UART_PAR_NONE</a> = 0, 
<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a5405c8d842bffa2f76999eef9cee32c3">UART_PAR_EVEN</a> = 1, 
<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a498f72ae68542763da3072d3e3af6603">UART_PAR_ODD</a> = 2, 
<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4adfb9d17fa33753ea5550e757b323bd46">UART_PAR_ZERO</a> = 3, 
<br />
&#160;&#160;<a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4a7ab50a9a14f4c614e875fbab74911afa">UART_PAR_ONE</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:ac70b5aa75500b8c45a51ec560deccfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">More...</a><br /></td></tr>
<tr class="separator:ac70b5aa75500b8c45a51ec560deccfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b49b65f3db709c408dc4db23a68895d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d">UART_close</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a6b49b65f3db709c408dc4db23a68895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a UART peripheral specified by the UART handle.  <a href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d">More...</a><br /></td></tr>
<tr class="separator:a6b49b65f3db709c408dc4db23a68895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de3c26cfe4ce6b7f350a6ea6e16801d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d">UART_control</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, unsigned int cmd, void *arg)</td></tr>
<tr class="memdesc:a9de3c26cfe4ce6b7f350a6ea6e16801d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given UART_Handle.  <a href="_u_a_r_t_8h.html#a9de3c26cfe4ce6b7f350a6ea6e16801d">More...</a><br /></td></tr>
<tr class="separator:a9de3c26cfe4ce6b7f350a6ea6e16801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60a36f7295d704926120d22f806dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1">UART_init</a> (void)</td></tr>
<tr class="memdesc:ab60a36f7295d704926120d22f806dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the UART module.  <a href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1">More...</a><br /></td></tr>
<tr class="separator:ab60a36f7295d704926120d22f806dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442ea1ec23901168da31726bb3254c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1">UART_open</a> (unsigned int index, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:a0442ea1ec23901168da31726bb3254c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral.  <a href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1">More...</a><br /></td></tr>
<tr class="separator:a0442ea1ec23901168da31726bb3254c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a> (<a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:a40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters.">UART_Params</a> struct to its defaults.  <a href="_u_a_r_t_8h.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">More...</a><br /></td></tr>
<tr class="separator:a40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2a04c09dc17886e69e361cd80aaedc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc">UART_write</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:a6f2a04c09dc17886e69e361cd80aaedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART with interrupts enabled.  <a href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc">More...</a><br /></td></tr>
<tr class="separator:a6f2a04c09dc17886e69e361cd80aaedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed09b432b5ebb7d88e78ccfe338e1bd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aed09b432b5ebb7d88e78ccfe338e1bd4">UART_writePolling</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:aed09b432b5ebb7d88e78ccfe338e1bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART, polling the peripheral to wait until new data can be written. Usage of this API is mutually exclusive with usage of <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a>.  <a href="_u_a_r_t_8h.html#aed09b432b5ebb7d88e78ccfe338e1bd4">More...</a><br /></td></tr>
<tr class="separator:aed09b432b5ebb7d88e78ccfe338e1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0482cd0ab9ee7e802c8e785a5754d16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d">UART_writeCancel</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a0482cd0ab9ee7e802c8e785a5754d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> function call.  <a href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d">More...</a><br /></td></tr>
<tr class="separator:a0482cd0ab9ee7e802c8e785a5754d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023152d57539cad94bdd813956013e73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73">UART_read</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a023152d57539cad94bdd813956013e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART with interrupt enabled.  <a href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73">More...</a><br /></td></tr>
<tr class="separator:a023152d57539cad94bdd813956013e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4c56b20ea1c4c33406d99369db3df1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aee4c56b20ea1c4c33406d99369db3df1">UART_readPolling</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:aee4c56b20ea1c4c33406d99369db3df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART without interrupts. This API must be used mutually exclusive with <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a>.  <a href="_u_a_r_t_8h.html#aee4c56b20ea1c4c33406d99369db3df1">More...</a><br /></td></tr>
<tr class="separator:aee4c56b20ea1c4c33406d99369db3df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c">UART_readCancel</a> (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> function call.  <a href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c">More...</a><br /></td></tr>
<tr class="separator:a51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>UART driver interface. </p>
<p>============================================================================</p>
<p>The UART header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ti/drivers/UART.h&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md101"></a>
Operation</h1>
<p>The UART driver simplifies reading and writing to any of the UART peripherals on the board with multiple modes of operation and performance. These include blocking, non-blocking, and polling as well as text/binary mode, echo and return characters. The board's UART pins must be configured before initializing the UART driver. The application initializes the UART driver by calling <a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module.">UART_init()</a> and is then ready to open a UART by calling <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a>, passing in a UART parameters data structure.</p>
<p>The APIs in this driver serve as an interface to a typical TI-RTOS application. The specific peripheral implementations are responsible to create all the SYS/BIOS specific primitives to allow for thread-safe operation.</p>
<p>The UART driver allows full duplex data transfers. Therefore, it is possible to call <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> and <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> at the same time (for either UART_MODE_CALLBACK and UART_MODE_BLOCKING modes). It is not possible, however, to issue multiple concurrent operations in the same direction. For example, if one thread calls UART_read(uart0, buffer0...), any other thread attempting UART_read(uart0, buffer1...) will result in an error of UART_ERROR, until all the data from the first <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> has been transferred to buffer0. This applies to both UART_MODE_CALLBACK and UART_MODE_BLOCKING modes. So applications must either synchronize <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> (or <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a>) calls that use the same UART handle, or check for the UART_ERROR return code indicating that a transfer is still ongoing.</p>
<h2><a class="anchor" id="autotoc_md102"></a>
Opening the driver</h2>
<div class="fragment"><div class="line"><a class="code" href="struct_u_a_r_t___config.html">UART_Handle</a>      handle;</div>
<div class="line"><a class="code" href="struct_u_a_r_t___params.html">UART_Params</a>      params;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="_u_a_r_t_8c.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a>(&amp;params);</div>
<div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#afadb98d0a0ef6e17240bab79306e7828">baudRate</a>  = someNewBaudRate;</div>
<div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a02e8b9127a7d6fa49021f01a7ee69ad2">writeDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div>
<div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a707659dcecb10f490000511ec2de2060">readDataMode</a> = <a class="code" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>;</div>
<div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a47382bd027b944868ce873ad71d29d0e">readReturnMode</a> = <a class="code" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>;</div>
<div class="line">params.<a class="code" href="struct_u_a_r_t___params.html#a61642ef82bbcfc98494739a98afff58a">readEcho</a> = <a class="code" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a>;</div>
<div class="line">handle = <a class="code" href="_u_a_r_t_8c.html#a0442ea1ec23901168da31726bb3254c1">UART_open</a>(someUART_configIndexValue, &amp;params);</div>
<div class="line"><span class="keywordflow">if</span> (!handle) {</div>
<div class="line">    System_printf(<span class="stringliteral">&quot;UART did not open&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Writing data</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hello[] = <span class="stringliteral">&quot;Hello World\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="_u_a_r_t_8c.html#a6f2a04c09dc17886e69e361cd80aaedc">UART_write</a>(handle, hello, <span class="keyword">sizeof</span>(hello));</div>
<div class="line">System_printf(<span class="stringliteral">&quot;The UART wrote %d bytes\n&quot;</span>, ret);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md104"></a>
Reading data</h2>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rxBuffer[20];</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="_u_a_r_t_8c.html#a023152d57539cad94bdd813956013e73">UART_read</a>(handle, rxBuffer, <span class="keyword">sizeof</span>(rxBuffer));</div>
<div class="line">System_printf(<span class="stringliteral">&quot;The UART read %d bytes\n&quot;</span>, ret);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md105"></a>
Implementation</h1>
<p>This module serves as the main interface for TI-RTOS applications. Its purpose is to redirect the module's APIs to specific peripheral implementations which are specified using a pointer to a <a class="el" href="struct_u_a_r_t___fxn_table.html" title="The definition of a UART function table that contains the required set of functions to control a spec...">UART_FxnTable</a>.</p>
<p>The UART driver interface module is joined (at link time) to a NULL-terminated array of <a class="el" href="struct_u_a_r_t___config.html" title="UART Global configuration.">UART_Config</a> data structures named <em>UART_config</em>. <em>UART_config</em> is implemented in the application with each entry being an instance of a UART peripheral. Each entry in <em>UART_config</em> contains a:</p><ul>
<li>(<a class="el" href="struct_u_a_r_t___fxn_table.html" title="The definition of a UART function table that contains the required set of functions to control a spec...">UART_FxnTable</a> *) to a set of functions that implement a UART peripheral</li>
<li>(void *) data object that is associated with the <a class="el" href="struct_u_a_r_t___fxn_table.html" title="The definition of a UART function table that contains the required set of functions to control a spec...">UART_FxnTable</a></li>
<li>(void *) hardware attributes that are associated with the <a class="el" href="struct_u_a_r_t___fxn_table.html" title="The definition of a UART function table that contains the required set of functions to control a spec...">UART_FxnTable</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md106"></a>
Stack requirements</h2>
<p>It is STRONGLY discouraged to perform <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> or UART_write calls within the driver's own callback function when in UART_MODE_CALLBACK. Doing so will incur additional task or system stack size requirements. See the peripheral implementations' documentation for stack size estimations. It is expected that the user perform his/her own stack and usage analysis when choosing to nest these calls.</p>
<h1><a class="anchor" id="autotoc_md107"></a>
Instrumentation</h1>
<p>The UART driver interface produces log statements if instrumentation is enabled.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Diagnostics Mask </th><th class="markdownTableHeadNone">Log details  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Diags_USER1 </td><td class="markdownTableBodyNone">basic operations performed  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Diags_USER2 </td><td class="markdownTableBodyNone">detailed operations performed  </td></tr>
</table>
<hr  />
 
<p class="definition">Definition in file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7e3562e7931cf51b41a32d8109072251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3562e7931cf51b41a32d8109072251">&#9670;&nbsp;</a></span>UART_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ERROR&#160;&#160;&#160;<a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga2ae076f4aae13ca8e2aea674207df0ad">UART_STATUS_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00287">287</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="ada620b673241eb6335a71e75da291716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada620b673241eb6335a71e75da291716">&#9670;&nbsp;</a></span>UART_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_WAIT_FOREVER&#160;&#160;&#160;(~0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait forever define. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00292">292</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a44620a9d91e0357ebc6f0a79984d9e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44620a9d91e0357ebc6f0a79984d9e1e">&#9670;&nbsp;</a></span>UART_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>, void *buf, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART driver when used in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> The callback can occur in task or HWI context. </p>
<dl class="section warning"><dt>Warning</dt><dd>Making <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> or <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> calls within its own callback routines are STRONGLY discouraged as it will impact Task and System stack size requirements! See the documentation for the specific driver implementations for additional estimated stack requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to read/write buffer</td></tr>
    <tr><td class="paramname">count</td><td>Number of elements read/written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00315">315</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="ae08ff15291bd6b21cb4e2eb1fce164a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08ff15291bd6b21cb4e2eb1fce164a6">&#9670;&nbsp;</a></span>UART_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_CloseFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn().">UART_CloseFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00459">459</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="ae8c7a79c58daec6f156815ebd9739c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c7a79c58daec6f156815ebd9739c69">&#9670;&nbsp;</a></span>UART_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___config.html">UART_Config</a> <a class="el" href="struct_u_a_r_t___config.html">UART_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Global configuration. </p>
<p>The <a class="el" href="struct_u_a_r_t___config.html" title="UART Global configuration.">UART_Config</a> structure contains a set of pointers used to characterize the UART driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_u_a_r_t_8c.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module.">UART_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8c.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module.">UART_init()</a> </dd></dl>

</div>
</div>
<a id="a4fc98447e6dd805e2d072917e8e6da3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc98447e6dd805e2d072917e8e6da3b">&#9670;&nbsp;</a></span>UART_ControlFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* UART_ControlFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, unsigned int cmd, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a4fc98447e6dd805e2d072917e8e6da3b" title="A function pointer to a driver specific implementation of UART_ControlFxn().">UART_ControlFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00465">465</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="addcc0767be6a635e2622cdd2cbf8f4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcc0767be6a635e2622cdd2cbf8f4fa">&#9670;&nbsp;</a></span>UART_DataMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a> <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. In UART_DATA_TEXT mode the driver will examine the UART_ReturnMode value. </p>

</div>
</div>
<a id="a2458fc15500d4596b67e695a62eef8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2458fc15500d4596b67e695a62eef8f9">&#9670;&nbsp;</a></span>UART_Echo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a> <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data when uses in UART_DATA_TEXT mode. This only applies to data received by the UART.</p>
<p>UART_ECHO_ON will echo back characters it received while in UART_DATA_TEXT mode. UART_ECHO_OFF will not echo back characters it received in UART_DATA_TEXT mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>

</div>
</div>
<a id="ad53155d6826ff6005b2a429d9ae20626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53155d6826ff6005b2a429d9ae20626">&#9670;&nbsp;</a></span>UART_FxnTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___fxn_table.html">UART_FxnTable</a> <a class="el" href="struct_u_a_r_t___fxn_table.html">UART_FxnTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation. </p>

</div>
</div>
<a id="a13cc669fae768d8212e6491ce71b28af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cc669fae768d8212e6491ce71b28af">&#9670;&nbsp;</a></span>UART_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___config.html">UART_Config</a>* <a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> call. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00296">296</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a2b3e89df3065fffb47e7354067c14d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e89df3065fffb47e7354067c14d1b">&#9670;&nbsp;</a></span>UART_InitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_InitFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn().">UART_InitFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00473">473</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="aacbb2d50547dee530b8c2666985efcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbb2d50547dee530b8c2666985efcd3">&#9670;&nbsp;</a></span>UART_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a> <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>

</div>
</div>
<a id="a821a1d8d175e0b1f656a00dc623d4860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821a1d8d175e0b1f656a00dc623d4860">&#9670;&nbsp;</a></span>UART_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a> <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>

</div>
</div>
<a id="a39e21ac60f24eb9ce32286e21de713d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e21ac60f24eb9ce32286e21de713d1">&#9670;&nbsp;</a></span>UART_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>(* UART_OpenFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1" title="A function pointer to a driver specific implementation of UART_OpenFxn().">UART_OpenFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00479">479</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a5e4fac552566aa6fce6ddda0ce1bc7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4fac552566aa6fce6ddda0ce1bc7b8">&#9670;&nbsp;</a></span>UART_PAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a> <a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>

</div>
</div>
<a id="acdbbaa6af11fae4b97cc55d1a309e063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbbaa6af11fae4b97cc55d1a309e063">&#9670;&nbsp;</a></span>UART_Params</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Parameters. </p>
<p>UART parameters are used to with the <a class="el" href="_u_a_r_t_8c.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> call. Default values for these parameters are set using <a class="el" href="_u_a_r_t_8c.html#a40e5c0823bb7ffd2e8fbf19f9f20b399" title="Function to initialize the UART_Params struct to its defaults.">UART_Params_init()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8c.html#a40e5c0823bb7ffd2e8fbf19f9f20b399" title="Function to initialize the UART_Params struct to its defaults.">UART_Params_init()</a> </dd></dl>

</div>
</div>
<a id="aa46296acc2c197a775d44458e1eca197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46296acc2c197a775d44458e1eca197">&#9670;&nbsp;</a></span>UART_ReadCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_ReadCancelFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn().">UART_ReadCancelFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00499">499</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a4d855b637a26d787afec822d4cd2978e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d855b637a26d787afec822d4cd2978e">&#9670;&nbsp;</a></span>UART_ReadFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* UART_ReadFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a4d855b637a26d787afec822d4cd2978e" title="A function pointer to a driver specific implementation of UART_ReadFxn().">UART_ReadFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00485">485</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a6b57fb6a7c48272141a727c7de7290e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b57fb6a7c48272141a727c7de7290e4">&#9670;&nbsp;</a></span>UART_ReadPollingFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* UART_ReadPollingFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a6b57fb6a7c48272141a727c7de7290e4" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn().">UART_ReadPollingFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00492">492</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="ac97d52284ddcb61165e13cfb46425fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97d52284ddcb61165e13cfb46425fd9">&#9670;&nbsp;</a></span>UART_ReturnMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a> <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="_u_a_r_t_8c.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> and <a class="el" href="_u_a_r_t_8c.html#aee4c56b20ea1c4c33406d99369db3df1" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. This mode only functions when in UART_DATA_TEXT mode.</p>
<p>UART_RETURN_FULL unblocks or performs a callback when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">UART operation </th><th class="markdownTableHeadNone">UART_RETURN_FULL </th><th class="markdownTableHeadNone">UART_RETURN_NEWLINE  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UART_read </td><td class="markdownTableBodyNone">Returns when buffer is full </td><td class="markdownTableBodyNone">Returns when buffer is full or newline was read  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UART_write </td><td class="markdownTableBodyNone">Sends data as is </td><td class="markdownTableBodyNone">Sends data with an additional newline at the end  </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>

</div>
</div>
<a id="a63afe876d1474c7497d90e1052049ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63afe876d1474c7497d90e1052049ed6">&#9670;&nbsp;</a></span>UART_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a> <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>

</div>
</div>
<a id="ac5a3d974279a2d161746dfbc8ca91774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a3d974279a2d161746dfbc8ca91774">&#9670;&nbsp;</a></span>UART_WriteCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_WriteCancelFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn().">UART_WriteCancelFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00521">521</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="abe7ee32e202ad90d912b27693fe33672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7ee32e202ad90d912b27693fe33672">&#9670;&nbsp;</a></span>UART_WriteFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* UART_WriteFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, const void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#abe7ee32e202ad90d912b27693fe33672" title="A function pointer to a driver specific implementation of UART_WriteFxn().">UART_WriteFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00505">505</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a68d0b77abdb9da6a868edc6529ae70ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d0b77abdb9da6a868edc6529ae70ff">&#9670;&nbsp;</a></span>UART_WritePollingFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* UART_WritePollingFxn) (<a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> handle, const void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a68d0b77abdb9da6a868edc6529ae70ff" title="A function pointer to a driver specific implementation of UART_WritePollingFxn().">UART_WritePollingFxn()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00513">513</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a694090fdb166f94ac30b809f9cba87b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694090fdb166f94ac30b809f9cba87b8">&#9670;&nbsp;</a></span>UART_DataMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8">UART_DataMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. In UART_DATA_TEXT mode the driver will examine the UART_ReturnMode value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8"></a>UART_DATA_BINARY&#160;</td><td class="fielddoc"><p>Data is not processed </p>
</td></tr>
<tr><td class="fieldname"><a id="a694090fdb166f94ac30b809f9cba87b8a87fdfb7ca981eab7f56c51380fd7094e"></a>UART_DATA_TEXT&#160;</td><td class="fielddoc"><p>Data is processed according to above </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00370">370</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="aac6a03c2e1d76f53e1d9d923dcdc24f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6a03c2e1d76f53e1d9d923dcdc24f2">&#9670;&nbsp;</a></span>UART_Echo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2">UART_Echo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data when uses in UART_DATA_TEXT mode. This only applies to data received by the UART.</p>
<p>UART_ECHO_ON will echo back characters it received while in UART_DATA_TEXT mode. UART_ECHO_OFF will not echo back characters it received in UART_DATA_TEXT mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd"></a>UART_ECHO_OFF&#160;</td><td class="fielddoc"><p>Data is not echoed </p>
</td></tr>
<tr><td class="fieldname"><a id="aac6a03c2e1d76f53e1d9d923dcdc24f2a6c4d8a2d4e30c22cf9fa45cd1bf79306"></a>UART_ECHO_ON&#160;</td><td class="fielddoc"><p>Data is echoed </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00388">388</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="adf245d5f10db0abcbd8ad62a0d80c694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf245d5f10db0abcbd8ad62a0d80c694">&#9670;&nbsp;</a></span>UART_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#adf245d5f10db0abcbd8ad62a0d80c694">UART_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a27d04dd1fa818f764eb9b8e849feb7ff"></a>UART_LEN_5&#160;</td><td class="fielddoc"><p>Data length is 5 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a5bfd5507335d394d826e560930ce2a12"></a>UART_LEN_6&#160;</td><td class="fielddoc"><p>Data length is 6 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a2ac8467047f55cc1954388bf94c72e35"></a>UART_LEN_7&#160;</td><td class="fielddoc"><p>Data length is 7 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="adf245d5f10db0abcbd8ad62a0d80c694a31abbaaeaa38a5c66fbe13bfc8ece221"></a>UART_LEN_8&#160;</td><td class="fielddoc"><p>Data length is 8 bits </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00398">398</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a2507a620dba95cd20885c52494d19e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2507a620dba95cd20885c52494d19e90">&#9670;&nbsp;</a></span>UART_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90">UART_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf"></a>UART_MODE_BLOCKING&#160;</td><td class="fielddoc"><p>Uses a semaphore to block while data is being sent. Context of the call must be a Task. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754"></a>UART_MODE_CALLBACK&#160;</td><td class="fielddoc"><p>Non-blocking and will return immediately. When <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> or <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> has finished, the callback function is called from either the caller's context or from an interrupt context. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00322">322</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="ac70b5aa75500b8c45a51ec560deccfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70b5aa75500b8c45a51ec560deccfc4">&#9670;&nbsp;</a></span>UART_PAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#ac70b5aa75500b8c45a51ec560deccfc4">UART_PAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a469955a283c95f261990ad07043d5d2d"></a>UART_PAR_NONE&#160;</td><td class="fielddoc"><p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a5405c8d842bffa2f76999eef9cee32c3"></a>UART_PAR_EVEN&#160;</td><td class="fielddoc"><p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a498f72ae68542763da3072d3e3af6603"></a>UART_PAR_ODD&#160;</td><td class="fielddoc"><p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4adfb9d17fa33753ea5550e757b323bd46"></a>UART_PAR_ZERO&#160;</td><td class="fielddoc"><p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a id="ac70b5aa75500b8c45a51ec560deccfc4a7ab50a9a14f4c614e875fbab74911afa"></a>UART_PAR_ONE&#160;</td><td class="fielddoc"><p>Parity bit is always one </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00420">420</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="acb5a82843435a1b5d51b6c27028d914f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5a82843435a1b5d51b6c27028d914f">&#9670;&nbsp;</a></span>UART_ReturnMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914f">UART_ReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> and <a class="el" href="_u_a_r_t_8h.html#aee4c56b20ea1c4c33406d99369db3df1" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. This mode only functions when in UART_DATA_TEXT mode.</p>
<p>UART_RETURN_FULL unblocks or performs a callback when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">UART operation </th><th class="markdownTableHeadNone">UART_RETURN_FULL </th><th class="markdownTableHeadNone">UART_RETURN_NEWLINE  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UART_read </td><td class="markdownTableBodyNone">Returns when buffer is full </td><td class="markdownTableBodyNone">Returns when buffer is full or newline was read  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UART_write </td><td class="markdownTableBodyNone">Sends data as is </td><td class="markdownTableBodyNone">Sends data with an additional newline at the end  </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5"></a>UART_RETURN_FULL&#160;</td><td class="fielddoc"><p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb5a82843435a1b5d51b6c27028d914fa3b8e419e0e12abf80b25f72d17745f76"></a>UART_RETURN_NEWLINE&#160;</td><td class="fielddoc"><p>Unblock/callback when newline character is received. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00355">355</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<a id="a176b71ca19bc13d7534fa30fc18c2243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176b71ca19bc13d7534fa30fc18c2243">&#9670;&nbsp;</a></span>UART_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a176b71ca19bc13d7534fa30fc18c2243">UART_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a176b71ca19bc13d7534fa30fc18c2243a9bfa599e95c5da9cfe5f964dab8a9c6c"></a>UART_STOP_ONE&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="a176b71ca19bc13d7534fa30fc18c2243a3f41137f3775e7d33fdb250471c0248e"></a>UART_STOP_TWO&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8h_source.html#l00410">410</a> of file <a class="el" href="_u_a_r_t_8h_source.html">UART.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6b49b65f3db709c408dc4db23a68895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b49b65f3db709c408dc4db23a68895d">&#9670;&nbsp;</a></span>UART_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a UART peripheral specified by the UART handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> has been called. </dd>
<dd>
Ongoing asynchronous read or write have been cancelled using <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call.">UART_readCancel()</a> or <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call.">UART_writeCancel()</a> respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned from <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00071">71</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a9de3c26cfe4ce6b7f350a6ea6e16801d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de3c26cfe4ce6b7f350a6ea6e16801d">&#9670;&nbsp;</a></span>UART_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UART_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given UART_Handle. </p>
<p>Commands for UART_control can originate from <a class="el" href="_u_a_r_t_8h.html" title="UART driver interface.">UART.h</a> or from implementation specific UART*.h (<em><a class="el" href="_u_a_r_t_c_c26_x_x_8h.html" title="UART driver implementation for a CC26XX UART controller.">UARTCC26XX.h</a></em>, <em>UARTTiva.h</em>, etc.. ) files. While commands from <a class="el" href="_u_a_r_t_8h.html" title="UART driver interface.">UART.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific UART*.h files add unique driver capabilities but are not API portable across all UART driver implementations.</p>
<p>Commands supported by <a class="el" href="_u_a_r_t_8h.html" title="UART driver interface.">UART.h</a> follow a UART_CMD_&lt;cmd&gt; naming convention.<br  />
 Commands supported by UART*.h follow a UART*_CMD_&lt;cmd&gt; naming convention.<br  />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<p>See <a class="el" href="group___u_a_r_t___c_m_d.html">UART_control command codes</a> for command codes.</p>
<p>See <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html">UART_control return status codes</a> for status codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> has to be called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART handle returned from <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_u_a_r_t_8h.html" title="UART driver interface.">UART.h</a> or UART*.h commands.</td></tr>
    <tr><td class="paramname">arg</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00079">79</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="ab60a36f7295d704926120d22f806dcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60a36f7295d704926120d22f806dcd1">&#9670;&nbsp;</a></span>UART_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the UART module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The UART_config structure must exist and be persistent before this function can be called. This function must also be called before any other UART driver APIs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00087">87</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a0442ea1ec23901168da31726bb3254c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0442ea1ec23901168da31726bb3254c1">&#9670;&nbsp;</a></span>UART_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a> UART_open </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given UART peripheral. </p>
<p>Function to initialize a given UART peripheral specified by the particular index value.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module.">UART_init()</a> has been called</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the UART indexed into the UART_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block. If NULL, default parameter values will be used. All the fields in this structure are RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UART_Handle upon success. NULL if an error occurs, or if the indexed UART peripheral is already opened.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#ab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module.">UART_init()</a> </dd>
<dd>
<a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle.">UART_close()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00100">100</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a40e5c0823bb7ffd2e8fbf19f9f20b399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e5c0823bb7ffd2e8fbf19f9f20b399">&#9670;&nbsp;</a></span>UART_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters.">UART_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_u_a_r_t___params.html" title="UART Parameters.">UART_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: readMode = UART_MODE_BLOCKING; writeMode = UART_MODE_BLOCKING; readTimeout = UART_WAIT_FOREVER; writeTimeout = UART_WAIT_FOREVER; readCallback = NULL; writeCallback = NULL; readReturnMode = UART_RETURN_NEWLINE; readDataMode = UART_DATA_TEXT; writeDataMode = UART_DATA_TEXT; readEcho = UART_ECHO_ON; baudRate = 115200; dataLength = UART_LEN_8; stopBits = UART_STOP_ONE; parityType = UART_PAR_NONE; </p>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00123">123</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a023152d57539cad94bdd813956013e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023152d57539cad94bdd813956013e73">&#9670;&nbsp;</a></span>UART_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UART_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART with interrupt enabled. </p>
<p>UART_read() reads data from a UART controller. The destination is specified by <em>buffer</em> and the number of bytes to read is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, UART_read() blocks task execution until all the data in buffer has been read.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>, UART_read() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t___params.html#a5457b86b6793f1c4757457b9b22e379d">UART_Params::readCallback</a> is called when the transfer is finished. The callback function can occur in the caller's context or in HWI or SWI context, depending on the device-specific implementation. An unfinished asynchronous read operation must always be cancelled using <a class="el" href="_u_a_r_t_8h.html#a51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call.">UART_readCancel()</a> before calling <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle.">UART_close()</a>.</p>
<p>UART_read() is mutually exclusive to <a class="el" href="_u_a_r_t_8h.html#aee4c56b20ea1c4c33406d99369db3df1" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. For an opened UART peripheral, either UART_read() or <a class="el" href="_u_a_r_t_8h.html#aee4c56b20ea1c4c33406d99369db3df1" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a> can be used, but not both.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call UART_read() from its own callback function when in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#aee4c56b20ea1c4c33406d99369db3df1" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned by <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer to which received data should be written</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, UART_ERROR on an error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00131">131</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a51ed7e94d5b409ca1fcb2d65c5a25c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ed7e94d5b409ca1fcb2d65c5a25c3c">&#9670;&nbsp;</a></span>UART_readCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_readCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a> operation and is only applicable in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned by <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00147">147</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="aee4c56b20ea1c4c33406d99369db3df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4c56b20ea1c4c33406d99369db3df1">&#9670;&nbsp;</a></span>UART_readPolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UART_readPolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART without interrupts. This API must be used mutually exclusive with <a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a>. </p>
<p>This function initiates an operation to read data from a UART peripheral.</p>
<p>UART_readPolling will not return until size data was read to the UART.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a023152d57539cad94bdd813956013e73" title="Function that reads data from a UART with interrupt enabled.">UART_read()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned by <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer in which received data should be written to</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, UART_ERROR on an error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00139">139</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a6f2a04c09dc17886e69e361cd80aaedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2a04c09dc17886e69e361cd80aaedc">&#9670;&nbsp;</a></span>UART_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UART_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART with interrupts enabled. </p>
<p>UART_write() writes data from a memory buffer to the UART interface. The source is specified by <em>buffer</em> and the number of bytes to write is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> blocks task execution until all the data in buffer has been written.</p>
<p>In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>, UART_write() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t___params.html#a0497d8a55aea66d3ab2118f8966e8e33">UART_Params::writeCallback</a> is called when the transfer is finished. The callback function can occur in the caller's task context or in a HWI or SWI context, depending on the device implementation. An unfinished asynchronous write operation must always be cancelled using <a class="el" href="_u_a_r_t_8h.html#a0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call.">UART_writeCancel()</a> before calling <a class="el" href="_u_a_r_t_8h.html#a6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle.">UART_close()</a>.</p>
<p>UART_write() is mutually exclusive to <a class="el" href="_u_a_r_t_8h.html#aed09b432b5ebb7d88e78ccfe338e1bd4" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written....">UART_writePolling()</a>. For an opened UART peripheral, either <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> or <a class="el" href="_u_a_r_t_8h.html#aed09b432b5ebb7d88e78ccfe338e1bd4" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written....">UART_writePolling()</a> can be used, but not both.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call UART_write() from its own callback function when in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#aed09b432b5ebb7d88e78ccfe338e1bd4" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written....">UART_writePolling()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned by <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A read-only pointer to buffer containing data to be written to the UART</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART. If an error occurs, <a class="el" href="_u_a_r_t_8h.html#a7e3562e7931cf51b41a32d8109072251">UART_ERROR</a> is returned. In <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a> mode, the return value is always 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00155">155</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="a0482cd0ab9ee7e802c8e785a5754d16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0482cd0ab9ee7e802c8e785a5754d16d">&#9670;&nbsp;</a></span>UART_writeCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_writeCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a> operation and is only applicable in <a class="el" href="_u_a_r_t_8h.html#a2507a620dba95cd20885c52494d19e90ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned by <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00171">171</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
<a id="aed09b432b5ebb7d88e78ccfe338e1bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed09b432b5ebb7d88e78ccfe338e1bd4">&#9670;&nbsp;</a></span>UART_writePolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UART_writePolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t_8h.html#a13cc669fae768d8212e6491ce71b28af">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART, polling the peripheral to wait until new data can be written. Usage of this API is mutually exclusive with usage of <a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a>. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p><a class="el" href="_u_a_r_t_8h.html#aed09b432b5ebb7d88e78ccfe338e1bd4" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written....">UART_writePolling()</a> will not return until all the data was written to the UART (or to its FIFO if applicable).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t_8h.html#a6f2a04c09dc17886e69e361cd80aaedc" title="Function that writes data to a UART with interrupts enabled.">UART_write()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle returned by <a class="el" href="_u_a_r_t_8h.html#a0442ea1ec23901168da31726bb3254c1" title="Function to initialize a given UART peripheral.">UART_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A read-only pointer to the buffer containing the data to be written to the UART</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART. If an error occurs, UART_ERROR is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_u_a_r_t_8c_source.html#l00163">163</a> of file <a class="el" href="_u_a_r_t_8c_source.html">UART.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astruct_u_a_r_t___params_html_a707659dcecb10f490000511ec2de2060"><div class="ttname"><a href="struct_u_a_r_t___params.html#a707659dcecb10f490000511ec2de2060">UART_Params::readDataMode</a></div><div class="ttdeci">UART_DataMode readDataMode</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00444">UART.h:444</a></div></div>
<div class="ttc" id="a_u_a_r_t_8c_html_a0442ea1ec23901168da31726bb3254c1"><div class="ttname"><a href="_u_a_r_t_8c.html#a0442ea1ec23901168da31726bb3254c1">UART_open</a></div><div class="ttdeci">UART_Handle UART_open(unsigned int index, UART_Params *params)</div><div class="ttdoc">Function to initialize a given UART peripheral.</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8c_source.html#l00100">UART.c:100</a></div></div>
<div class="ttc" id="astruct_u_a_r_t___config_html"><div class="ttname"><a href="struct_u_a_r_t___config.html">UART_Config</a></div><div class="ttdoc">UART Global configuration.</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00571">UART.h:571</a></div></div>
<div class="ttc" id="a_u_a_r_t_8c_html_a023152d57539cad94bdd813956013e73"><div class="ttname"><a href="_u_a_r_t_8c.html#a023152d57539cad94bdd813956013e73">UART_read</a></div><div class="ttdeci">int UART_read(UART_Handle handle, void *buffer, size_t size)</div><div class="ttdoc">Function that reads data from a UART with interrupt enabled.</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8c_source.html#l00131">UART.c:131</a></div></div>
<div class="ttc" id="astruct_u_a_r_t___params_html_afadb98d0a0ef6e17240bab79306e7828"><div class="ttname"><a href="struct_u_a_r_t___params.html#afadb98d0a0ef6e17240bab79306e7828">UART_Params::baudRate</a></div><div class="ttdeci">uint32_t baudRate</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00447">UART.h:447</a></div></div>
<div class="ttc" id="a_u_a_r_t_8h_html_acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5"><div class="ttname"><a href="_u_a_r_t_8h.html#acb5a82843435a1b5d51b6c27028d914fa50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a></div><div class="ttdeci">@ UART_RETURN_FULL</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00357">UART.h:357</a></div></div>
<div class="ttc" id="astruct_u_a_r_t___params_html"><div class="ttname"><a href="struct_u_a_r_t___params.html">UART_Params</a></div><div class="ttdoc">UART Parameters.</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00436">UART.h:436</a></div></div>
<div class="ttc" id="a_u_a_r_t_8h_html_a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8"><div class="ttname"><a href="_u_a_r_t_8h.html#a694090fdb166f94ac30b809f9cba87b8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a></div><div class="ttdeci">@ UART_DATA_BINARY</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00371">UART.h:371</a></div></div>
<div class="ttc" id="astruct_u_a_r_t___params_html_a61642ef82bbcfc98494739a98afff58a"><div class="ttname"><a href="struct_u_a_r_t___params.html#a61642ef82bbcfc98494739a98afff58a">UART_Params::readEcho</a></div><div class="ttdeci">UART_Echo readEcho</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00446">UART.h:446</a></div></div>
<div class="ttc" id="a_u_a_r_t_8c_html_a40e5c0823bb7ffd2e8fbf19f9f20b399"><div class="ttname"><a href="_u_a_r_t_8c.html#a40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a></div><div class="ttdeci">void UART_Params_init(UART_Params *params)</div><div class="ttdoc">Function to initialize the UART_Params struct to its defaults.</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8c_source.html#l00123">UART.c:123</a></div></div>
<div class="ttc" id="a_u_a_r_t_8c_html_a6f2a04c09dc17886e69e361cd80aaedc"><div class="ttname"><a href="_u_a_r_t_8c.html#a6f2a04c09dc17886e69e361cd80aaedc">UART_write</a></div><div class="ttdeci">int UART_write(UART_Handle handle, const void *buffer, size_t size)</div><div class="ttdoc">Function that writes data to a UART with interrupts enabled.</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8c_source.html#l00155">UART.c:155</a></div></div>
<div class="ttc" id="astruct_u_a_r_t___params_html_a47382bd027b944868ce873ad71d29d0e"><div class="ttname"><a href="struct_u_a_r_t___params.html#a47382bd027b944868ce873ad71d29d0e">UART_Params::readReturnMode</a></div><div class="ttdeci">UART_ReturnMode readReturnMode</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00443">UART.h:443</a></div></div>
<div class="ttc" id="astruct_u_a_r_t___params_html_a02e8b9127a7d6fa49021f01a7ee69ad2"><div class="ttname"><a href="struct_u_a_r_t___params.html#a02e8b9127a7d6fa49021f01a7ee69ad2">UART_Params::writeDataMode</a></div><div class="ttdeci">UART_DataMode writeDataMode</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00445">UART.h:445</a></div></div>
<div class="ttc" id="a_u_a_r_t_8h_html_aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd"><div class="ttname"><a href="_u_a_r_t_8h.html#aac6a03c2e1d76f53e1d9d923dcdc24f2a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a></div><div class="ttdeci">@ UART_ECHO_OFF</div><div class="ttdef"><b>Definition:</b> <a href="_u_a_r_t_8h_source.html#l00389">UART.h:389</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_60925fc218da8ca7908795bf5f624060.html">Drivers</a></li><li class="navelem"><a class="el" href="dir_6216724b11e242fa87308a82dd4fb034.html">UART</a></li><li class="navelem"><a class="el" href="_u_a_r_t_8h.html">UART.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
